
\chapter{Úvod}

V současném světě hrají superskalární procesory klíčovou roli, tato technologie je základem téměř všech moderních výkonných čipů.
Je důležité, aby programátoři chápali jejich fungování a důsledky, zejména pak dopad na výkon programů a algoritmů, které navrhují.
Složité mechanismy jako spekulativní vykonávání instrukcí, vyrovnávací paměť či predikce skoků mohou ale být pro studenty obtížně pochopitelné.

Proto je klíčové hledat způsoby, jak usnadnit výuku a poskytnout studentům nástroje, které jim pomohou lépe porozumět konceptům superskalárních procesorů.
Vytvoření interaktivních nástrojů a zlepšení jejich dostupnosti mohou být klíčem k tomu, aby se tato komplexní témata stala pro studenty přístupnějšími a snáze pochopitelnými.

V~minulých letech na Fakultě informačních technologií VUT v~Brně vznikl výukový simulátor superskalárního procesoru architektury RISC-V \cite{horkySim, vavraSim} pro potřeby předmětu Architektury výpočetních systémů.
Simulátor v~současné době slouží jako interaktivní a názorná ukázka probíraných principů.
V simulátoru je možné nastavit libovolný program, krokovat jeho vykonání po jednotlivých taktech a prohlížet aktuální stav procesoru.

Cílem této práce je navázat na předchozí vývoj a vylepšit simulátor v~několika směrech.
Nové řešení bude implementováno jako dva nezávislé programy: webová aplikace a simulační server.
Jedním z hlavních cílů je vylepšit rozhraní simulátoru, což by mělo pozvednout jeho užitečnost a přilákat více uživatelů.
Web je moderním způsobem vývoje a distribuce aplikací.
Hlavní přínos by měl spočívat v dramaticky lepší přístupnosti aplikace, jelikož již nebude nutné provádět její instalaci.
Webové technologie také umožní implementovat vizuálně bohatější a názornější prezentaci.

Druhým cílem je zvýšení kvality simulace.
V tomto ohledu bude pozornost věnována především novým funkcím, doplnění instrukční sady a opravě chyb.
Proběhne také rozsáhlá refaktorizace kódu současného řešení, jejíž účelem bude umožnění následné implementace nových funkcí.

V~první části práce se v kapitolách \ref{scalarchapter} a \ref{superscalarchapter} zaměřuji na principy, na kterých jsou moderní superskalární procesory založeny.
Uvedeny jsou především ty principy, které jsou v~simulátoru demonstrovány, například spekulativní zpracování instrukcí nebo předvídání skoků.
Kapitola \ref{riscvchapter} krátce uvádí základy instrukční sady RISC-V.
V kapitole \ref{webchapter} jsou prozkoumány metody tvorby webových aplikací a jejich nasazení do provozu.
Je zmíněna knihovna React, která bude v projektu využita. 
Následně v kapitole \ref{chapteroldsolution} analyzuji dosavadní stav simulátoru.
Výstupem analýzy je výčet zlepšení stávajících mechanismů a návrh zcela nových funkcí.
Výsledný plán je rozveden v kapitole \ref{navrhrozsirenisimulatoru}.
Nejdůležitějšími z vylepšení budou aplikační rozhraní pro simulátor a integrace s překladačem jazyka C.

V~závěrečné části práce je detailně prezentováno provedení navrženého řešení.
Každá ze dvou částí řešení je popsána samostatně.
Kapitola \ref{Implementacerozs} se věnuje implementaci rozšíření simulátoru a soustředí se především na simulační API a další nové funkce.
Kapitola \ref{implementaceweboveaplikace} se podrobněji rozebírá realizace uživatelského rozhraní webové aplikace.

Kapitola \ref{testingchapter} uvádí postupy testování výsledné aplikace včetně výsledků uživatelského testování a úprav implementovaných v reakci na zpětnou vazbu.  

%
% Superskalární procesory
%

\chapter{Skalární procesor}
\label{scalarchapter}
% pohled programátora a pohled HW
% jak se zvyšuje výkon
% funkční jednotky
% 
% superskalár
% konflikty
% algoritmy tomasulo

Jádro procesoru představuje centrální prvek CPU, který provádí výpočet popsaný instrukcemi určité \emph{instrukční sady}.
Hlavní motivací při jeho hardwarové implementaci je rychlost výpočtu.
Protiváhami tohoto úsilí je především cena a spotřeba výsledného čipu.
V~této kapitole popíšu různé techniky využívané v~efektivních implementacích jader procesorů.

Instrukční sada tvoří \emph{programátorův model CPU}.
Jedná se o~abstraktní reprezentaci funkcionality a chování procesoru s~cílem usnadnění vyvíjení kódu.
Příklady instrukční sady jsou RISC-V, nebo Intel 64.

Instrukce je základním prvkem výpočtu.
Příkladem instrukce může být sečtení dvou čísel, nebo načtení z~paměti.
Z~abstraktního pohledu se procesor nachází v~určitém stavu a vykonáním každé instrukce se dostává do následujícího stavu.
Tento stav je představován hodnotami v~registrech.
Stav procesoru a stav hlavní paměti společně tvoří stav výpočtu.

Instrukční sada pouze \emph{popisuje prostředí a zdroje}, které program může využít.
Procesor může výpočty docílit libovolným způsobem, pokud se výpočet navenek jeví v~souladu s~instrukční sadou.
Této volnosti využívá hardware, který může zpracovávat více instrukcí současně, a to i \emph{mimo původní pořadí} programu, případně i \emph{spekulativně}. \cite{QuantApproach}

Podívejme se nejdříve na skalární procesor.
Skalární procesor paralelně zpracovává instrukce lineární linkou o~pěti stupních.

\section{Složky výpočetního jádra}
% https://www.cise.ufl.edu/~mssz/CompOrg/CDA-proc.html

Každá instrukce zpracovávaná skalárním procesorem prochází \emph{řetězenou linkou}.
V~každém taktu procesoru projde instrukce jednou fází.
To znamená, že v~ideálním případě procesor opustí v~každém taktu jedna instrukce.
Linka je dělena do následujících fází \cite{avs}:
\begin{enumerate}
    \item \emph{Fetch} -- Načtení instrukce,
    \item \emph{Decode} -- Dekódování instrukce, čtení registrů,
    \item \emph{Execute} -- Vykonání samotného výpočtu,
    \item \emph{Memory Access} -- Přístup k~paměti,
    \item \emph{Write Back} -- Zápis do registrů (propsání stavu procesoru).
\end{enumerate}

Tato stádia jsou vhodně zvolena, protože jejich provedení je \emph{nezávislé}.
Jejich nezávislost dovoluje vydělit pro každou fázi speciální hardware a jejich výpočet \emph{paralelizovat}.
\cite{OrganizationAndDesign}

Ne každá instrukce potřebuje k~výpočtu všechna stádia.
Například uložení do hlavní paměti nevyžaduje poslední fázi zápisu do registru.
V~takovém případě se v~dané fázi neprovede žádný výpočet. 

\subsection{Fáze výpočtu}
\label{fazeVypoctu}
% https://en.wikipedia.org/wiki/Classic_RISC_pipeline

Následuje detailnější popis fází klasické pětistupňové linky.

\subsubsection{Instruction Fetch (IF)}

Prvním krokem zpracování instrukce je její načtení z~paměti.
Z~paměťového modulu je načtena instrukce na adrese uložené v~registru \texttt{PC}.
Implementace mají pro tento účel dedikovanou vyrovnávací paměť a jednotku přednačítání, které zajišťují, že tato fáze proběhne v~jednom cyklu. \cite{avs}

Registr \texttt{PC} je ovlivňován skokovými instrukcemi.
Jejich výsledky jsou ale známy až v~pozdějších fázích linky.
Proto jednotka fetch v~taktech, kdy není známa adresa následující instrukce, vkládá do linky prázdné instrukce (\texttt{nop}, nebo také \emph{bubbles}).

Jedním způsobem, jak na výpočet skoku nemuset čekat, je skok \emph{předpovědět}.
Tento koncept bude rozveden v~sekci \ref{branchpredict}.

\subsubsection{Instruction Decode (ID)}

Během této fáze jsou binární instrukce dekódovány -- převedeny na interní reprezentaci CPU.
Tato fáze také zahrnuje identifikaci operačního kódu a načtení příslušných registrů z~registrového pole.
Hodnoty operandů a operační kód jsou linkou předány další fázi.

Ve fázi decode je také často implementována výkonnostní optimalizace pro skokové instrukce.
Decode je rozšířen o~další hardware, který dokáže vypočítat cíl a podmínku skoku.
Předsunutím výpočtu skoku z~fáze execute o~fázi dříve se sníží pokuta o~1 takt.

\subsubsection{Execute (EX)}

Ve fázi execute dochází k~provedení výpočtu instrukce.
Hardware zahrnuje ALU, posuvný registr, násobičku a děličku.
Výpočet probíhá nad daty načtenými ve fázi ID.

Aritmetické a logické instrukce vykonávají své operace, paměťové instrukce zde vypočítají adresu pro přístup do paměti a skokové instrukce počítají podmínku a adresu skoku.

Délka fáze execute se může mezi instrukcemi významně lišit.
Tabulka \ref{table:ex_latency} ukazuje několik instrukcí implementace Intel Ice Lake instrukční sady x86.
% todo jak se to řeší v lince?

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
Instrukce & Latence (cykly) & Popis                                                  \\ \hline\hline
MOV r, r  & 1       & Kopie hodnoty mezi registry                                    \\ \hline
CMP r, r  & 1       & Porovnání hodnot, nastavení příznaků                           \\ \hline
ADD (32b) & 1       & Součet dvou hodnot v~registrech (šířka 32 bitů)                \\ \hline
MUL (32b) & 4       & Násobení dvou hodnot v~registrech (šířka 32 bitů)              \\ \hline
DIV (32b) & 12      & Dělení dvou hodnot v~registrech (šířka 32 bitů)                \\ \hline
FMUL      & 4       & Násobení dvou hodnot v~registrech (float 32 bitů)              \\ \hline
FSIN      & 60-120  & Výpočet funkce $sin(x)$                                        \\ \hline
\end{tabular}
\caption{Vybrané instrukce a jejich latence v~cyklech architektury Intel Ice Lake. Předpokládá se, že neproběhnou přístupy do paměti nevzniknou výjimky. \cite{instructionTables}}
\label{table:ex_latency}
% https://www.agner.org/optimize/instruction_tables.pdf
% strana 348
\end{table}

\subsubsection{Memory Access (MA)}

Fáze \uv{Memory Access} v~CPU zahrnuje přístup do paměti pro čtení nebo zápis dat.
Využívá k~němu adresu, která byla dříve vypočtena ve fázi execute.
Instrukce, které nepřistupují k~paměti v~této fázi neprovádí žádnou operaci.

Pokud proces pracuje v~režimu s~\emph{virtuálním adresovým prostorem}, je nutné virtuální adresu přeložit na fyzickou adresu.
K~překladu slouží hardwarové jednoty PT walker a Translation Lookaside Buffer (TLB).

Délka přístupu do hlavní paměti (DRAM) může trvat přibližně 100 nanosekund, tedy 100 taktů při frekvenci 1 GHz \cite{avs}.
Pokud by všechny přístupy do paměti byly vyřízeny v~hlavní paměti, čas přístupu do paměti by dominoval výpočtu.
Za účelem zkrácení doby přístupu procesor k~paměti přistupuje skrze systém \emph{cache}.
Cache kopíruje část hodnot z~hlavní paměti do paměti s~významně kratší dobou přístupu, čímž zajišťuje, že fáze MA může být provedena v~rámci cyklu.
Pokud hodnota v~cache není, je nutné celou linku zastavit a počkat na načtení z~hlavní paměti.
Detailnější popis vyrovnávací paměti je uveden v~sekci \ref{cache}.

Zápisy do paměti jsou nejdříve provedeny pouze do dočasného registru, aby mohly být v~případě výjimky anulovány.

\subsubsection{Write Back (WB)}

V~této fázi dochází k~zápisu výsledku instrukce do registrů.
K~registrům v~rámci cyklu přistupuje i hardware fáze decode.
Tento strukturní konflikt musí být vyřešen.

Jelikož je WB poslední fází, jsou zde řešeny výjimky, které jsou sem propagovány z~předešlých fází.
Výjimka je obsloužena ve dvou krocích: (1) linka je vypláchnuta a (2) PC je nastaven na adresu procedury, která výjimku ošetřuje.

\subsection{Řetězená linka}

Řetězení je formou časového paralelismu.
Více instrukcí postupuje jednotlivými stupni linky najednou, čímž zvyšují vytížení a propustnost procesoru.
Jednotlivé stupně jsou spojeny za sebou, mezi každými dvěma stupni se nacházejí registry pro předání dat.
Rozdělením zpracování každého z~$n$ kroků do speciální hardwarové stanice je možné v~procesoru vytvořit řetězenou linku (\emph{pipeline}) hloubky $n$.
Maximální možné zrychlení linky odpovídá hloubce linky.
Ideálně v~každém taktu procesor opouští jedna instrukce a $IPC = 1$ (IPC -- instruction per clock).

Pro dosažení maximálního zrychlení je nutné zajistit nepřetržitý přísun nezávislého kódu ke zpracování a stejnou dobu výpočtu každého stupně.
Pokud výpočty stupňů nejsou stejně dlouhé, je nutné jako čas cyklu zvolit nejdelší z~nich.
Náběh a doběh linky a zpoždění registrů mezi jednotlivými stupni se při výpočtu zrychlení zanedbávají.

Kromě výše uvedených komplikací je v~reálném kódu propustnost snižována zastavováním linky (\emph{stall}).
Důvodem zastavování linky jsou \emph{konflikty}. \cite{OrganizationAndDesign}

V~jádře se nachází řídící logika (control unit), která signály ovládá linku.
Jednoduchá řídící logika může být implementována jako konečné stavové řízení.
\cite{OrganizationAndDesign}

\subsubsection{Konflikty}
\label{konfliktySubSub}

Mezi dvojicí instrukcí dochází k~datovému konfliktu, když jedna instrukce provádí výpočet nad daty generovanými druhou instrukcí.
Tuto situaci označujeme \emph{read after write} (RAW).
K~předání dat dochází prostřednictvím registrů nebo hlavní paměti.
Tato závislost může při paralelizaci ve zřetězené lince způsobit chybný výpočet.
Stát se tak může, pokud druhá instrukce začne výpočet dříve, než ho první instrukce zpřístupní.

Řešením konfliktu je pozdržení výpočtu dokud výsledek instrukce není k~dispozici.
Obrázek \ref{dataconflictsfrombook} ilustruje situaci, při které se musí linka zastavit pro zachování správnosti výpočtu.
Zvýrazněné závislosti mezi registry ukazují, že hodnota \texttt{\$2} čtená instrukcí \texttt{and} není výsledkem předchozí instrukce.
Konflikty mohou být částečně kompenzovány vhodným návrhem programu, respektive překladačem, který kód přeuspořádá tak, aby maximálně vykryl čekání na konflikty užitečnou prací.
% todo detekce a forwarding

Pokročilejším řešením je předávání dat mezi fázemi linky speciálními cestami, takzvanými zkratkami.
Zkratky mohou eliminovat potřebu zastavovat linku, čímž zvýší její propustnost. \cite{avs}

\begin{figure}[ht]\centering
  \centering
  \includegraphics[width=15cm]{obrazky-figures/conflicts.png}
  \caption{Sekvence instrukcí vykonávaných ve skalární lince. \cite{OrganizationAndDesign}}
  \label{dataconflictsfrombook}
\end{figure}

\section{Vyrovnávací paměť}
\label{cache}
% todo

Paměť, která je dostatečně rychlá pro současné procesory, je zároveň velmi drahá.
Řešením tohoto problému je \emph{hierarchie pamětí} -- víceúrovňová struktura, kde úrovně blíž procesoru mají menší kapacitu, ale větší rychlost.
Výsledkem je vyvážený stav mezi výkonem a cenou. \cite{avs}

Hierarchie pamětí funguje dobře, protože přístupy do paměti nebývají zcela náhodné, ale řídí se \emph{principem lokality}.
Prvním typem lokality je časová lokalita.
Ta tvrdí, že k~paměťovým místům, ke kterým bylo přistoupeno nedávno, bude pravděpodobně v~blízké době přistoupeno znovu.

Druhým typem lokality je prostorová lokalita.
Ta předvídá, že k~fyzicky blízkým paměťovým místům se přistupuje blízko v~čase.

Pokud programy tyto principy při práci s~pamětí dodržují, mají tendenci vykazovat lepší výkon.
\cite{QuantApproach}

Hierarchie pamětí na nejrychlejší úrovni využívá registry.
Na další úrovni je vyrovnávací paměť (cache), poslední úroveň tvoří hlavní paměť.
Modely s~více úrovněmi cache jsou běžné, k~popsání základních principů se ale budu věnovat modelu s~jednou úrovní cache.
Programátor s~pamětí pracuje jako s~celkem, hierarchie pamětí se projevuje pouze rychlostí výpočtu.

Cache obsahuje části hlavní paměti (bloky) se kterými procesor momentálně pracuje.
Nové bloky jsou alokovány při čtení nebo zápisu na paměťové místo, které se v~cache momentálně nenachází.
Záznam v~cache obsahuje informaci o~původní lokaci bloku v~paměťovém prostoru, aby později mohl být vrácen do hlavní paměti.
Bloky jsou v~paměti zarovnané na násobek své velikosti.

Nejčastěji používaná strategie ukládání bloků je \emph{asociativní cache}.
Úložiště pro bloky je v~této variantě rozděleno do skupin o~$m$ blocích.
Každý blok hlavní paměti je částí své adresy (indexem) mapován na právě jednu skupinu.

Zajímavé jsou krajní případy.
Pokud $m = 1$, potom se cache nazývá přímo mapovaná.
Pokud $m$ odpovídá kapacitě cache, potom se cache nazývá plně asociativní.

Pokud ve skupině není pro nový blok místo, je nutné jeden blok vybrat, přemístit ho zpět do hlavní paměti a tím místo uvolnit.
Nejznámější strategie výběru bloku ve skupině (victim) jsou:
\begin{itemize}
    \item náhodný výběr,
    \item FIFO (výběr nejstaršího bloku),
    \item LRU (nejdéle nepoužitý blok).
\end{itemize}
Efektivita cache se vyjadřuje četností nalezení požadovaného bloku (hit rate) v~procentech.

Hledání bloku ve skupině je prováděno paralelním porovnáním jiné části adresy (tagu).
Použití částí adresy je naznačeno na obrázku \ref{cachelineaddress}.
Prvních \texttt{t} bitů je použito jako \emph{tag} k~vyhledání v~rámci skupiny.
Následujících \texttt{k} bitů adresuje skupinu a posledních \texttt{b} bitů adresuje obsah bloku.

\begin{figure}[ht]\centering
  \includegraphics[width=11cm]{obrazky-figures/cacheline.png}
  \caption{Adresa paměti a její části.}
  \label{cachelineaddress}
\end{figure}

% todo víceúrovňová cache

\chapter{Superskalární procesor}
\label{superscalarchapter}
% multiple issue
% https://en.wikipedia.org/wiki/Superscalar_processor

% e performance of a computer is determined by three key
% factors: instruction count, clock cycle time, and clock cycles per instruction (CPI).
Délka výpočtu je určena třemi hlavními faktory: počtem instrukcí, frekvencí hodinového signálu a počtem instrukcí provedených za hodinový signál (\emph{Instructions Per Clock -- IPC}).
Architektura superskalárních procesorů zvyšuje výkon zvýšením IPC, typicky až nad hodnotu 1 -- jinými slovy, mohou vykonat 2 a více instrukcí ve stejný čas. \cite{QuantApproach}

Superskalární procesory rozšiřují řetězení na úrovni instrukcí ze skalárních řetězených procesorů.
K~časovému paralelismu přidávají \emph{prostorový paralelismus}, který spočívá v~rozšíření linky na $m$ instrukcí v~každém stupni a duplikací potřebných hardwarových jednotek.
Výsledkem je, že superskalární procesory mohou vydat k~výpočtu více instrukcí v~jednom taktu.
Cenou za zrychlení je zvýšení složitosti obvodu a tím nižší dosažitelný kmitočet, vyšší spotřeba energie a větší plocha čipu.

Existuje velké množství technik sloužících ke snižování doby zastavení linky.
V~této kapitole je blíže rozvedeno dynamické plánování, provádění kódu spekulativně a mimo pořadí.
Tyto koncepty bývají vysvětlovány a implementovány zároveň, pokusím se je ale vysvětlit izolovaně.
Zmíněné metody jsou pouze výběrem z~možných způsobů implementace superskalárních procesorů.

% in order superscalar
% scoreboarding??

\section{Konflikty}
\label{conflicts}

Kapitola o~skalárních procesorech (viz sekce \ref{konfliktySubSub}) definovala konflikt jako datovou závislost mezi dvěma instrukcemi.
Pro superskalární procesory je užitečné tento problém rozvést blíže.

V~případě, kdy dochází k~přeuspořádání pořadí vykonání instrukcí, je nutné uvažovat i \emph{nepravé} datové konflikty.
Pořadí pravých datových konfliktů (RAW) musí být respektováno, protože na rozdíl od nepravých nesou význam výpočtu. Jinými slovy nelze prohodit pořadí vykonání instrukcí s~pravým datovým konfliktem.

Nepravé konflikty můžeme charakterizovat jako konflikty jmen.
Vznikají znovupoužitím jména paměťového místa v~důsledku konečného počtu registrů, nebo vícenásobným vykonáním stejné instrukce.
Důležité je, že nepravou závislost lze na rozdíl od pravé závislosti odstranit bez ovlivnění správnosti výpočtu, protože mezi instrukcemi nejsou vyměňována žádná data \cite{QuantApproach}.
Nepravé závislosti lze řešit přejmenováním při tvorbě programu (programátorem nebo překladačem), nebo za běhu řídícím hardwarem procesoru.
Algoritmy Scoreboarding a Tomasulo, které jsou při řešení konfliktů využívány, uvedu v~sekci \ref{chap:ooo}.

Obrázek \ref{dataconflicts} vizualizuje pravé i nepravé konflikty mezi registry.
Nepravé konflikty jsou zobrazeny přerušovanou čarou, pravé konflikty plnou čarou.

\begin{figure}[ht]\centering
    % add a2, a0, a1
    % mul a3, a2, a1
    % sub a1, a0, a4
    % xor a3, a5, a6
  \centering
  \includegraphics[width=13cm]{obrazky-figures/dataconflicts.png}
  \caption{Program a jeho datové závislosti zobrazené jako graf.}
  \label{dataconflicts}
\end{figure}

\subsection{Řídící konflikty}

Skokové instrukce manipulují programový čítač (PC).
Důsledkem je, že pořadí vykonání instrukcí je známo až při samotném výpočtu.
Adresa následující instrukce není při zřetězeném zpracování známa po prvním stupni linky (procesor nezná ani typ zpracovávané instrukce, dokud není dekódována), procesor tedy typicky předpokládá, že instrukce skoková není a začíná zpracovávat následující instrukci.

Dokud není vypočítána adresa následující instrukce, může být počítána špatná větev programu, proto je žádoucí tento výpočet urychlit.
Techniky pro eliminaci pokut skokových instrukcí zahrnují predikci skoků a předsazení výpočtu podmínky v~lince.
Pokud dojde ke zpracovávání nesprávné instrukce, musí být z~linky odstraněna.

\subsection{Strukturní konflikty}

Ke strukturnímu konfliktu dochází, pokud vykonání dvou instrukcí vyžaduje stejný prostředek.
Prostředkem je myšlen hardwarový modul, například funkční jednotka, nebo zápisová brána.

Tento typ konfliktu se řeší serializací zpracování, neboli čekáním.
Dopady konfliktů se zmenšují znásobením hardwaru, například přidáním více aritmetických jednotek (ALU).

\section{Zpracování instrukcí mimo pořadí}
\label{chap:ooo}
% https://stackoverflow.com/questions/10074831/what-is-general-difference-between-superscalar-and-out-of-order-ooo-execution
% https://stackoverflow.com/questions/49601910/out-of-order-execution-vs-speculative-execution

Většina procesorů se zpracováním mimo pořadí jsou zároveň superskalární, ale nemusí být nutně.
Během výpočtu musí být zachována platnost programovacího modelu, který říká, že projevy instrukcí musí být aplikovány v~pořadí.
Zpracování instrukcí mimo pořadí dovoluje provádět práci na jiných instrukcích, než ta, která je právě v~pomyslné lince na řadě, aniž by model porušila.

Instrukce nemohou být vykonávány v~libovolném pořadí, algoritmus musí instrukci označit jako připravenou k~vykonání.
Analýza závislostí spočívá v~detekci datových konfliktů registrů tak, jak je popsána v~předešlé sekci \ref{conflicts}.
Komplikace nastává u~paměťových operací -- konflikty RAW, WAW a WAR nelze odhalit analýzou závislostí registrů, protože konflikty vznikají v~hlavní paměti a mohou být ověřeny až jsou vypočítány adresy. 

% limited OOO - předbíhání jen některého druhu (load before load)
Aby byla dodržena sémantika programu a zároveň bylo umožněno vykonávat paměťové instrukce mimo pořadí, je v~procesorech zaveden koncept \emph{relaxované paměťové konzistence} \cite{avs}.
Čtení a zápisy se mohou přeuspořádat, pokud není narušena správnost programu.
Pokud je z~nějakého důvodu nutné vynutit pořadí paměťových operací, je nutné vložit explicitní bariéry.
Paměťové instrukce za bariérou se začnou vykonávat až jakmile jsou všechny paměťové instrukce před bariérou dokončeny.
% release, acquire, ...

Linka procesoru se dělí na dvě části. 
Front-end superskalárního procesoru odpovídá stupňům Instruction Fetch (IF) a Instruction Decode (ID).
Back-end odpovídá stupňům Execute (EX), Memory Access (MA) a Write Back (WB).
Front-end pracuje v~pořadí programu.
Back-end pracuje mimo pořadí programu (OOO -- out of order), instrukce back-end opouští opět v~původním pořadí.
V~rámci back-endu se mohou libovolně promísit přístupy do paměti a vykonávání všech instrukcí v~okně. Stále ale musí být respektovány datové závislosti.

% fáze vydání nebo potvrzení?
V~cyklu zpracování instrukce přibývá fáze potvrzení instrukce (\emph{instruction commit}).
Vydání proběhne jakmile je instrukce na řadě a výsledek je vypočítán.
Výsledkem vydání je propsání do vnějšího stavu procesoru.

Procesor identifikuje nezávislé instrukce a vykoná je paralelně.
Tím snižuje počet zastavení linky a zvyšuje IPC.

Skokové instrukce představují asi 20\% instrukcí programu.
Z~toho vyplývá, že okno instrukcí, o~kterých víme, že budou vykonány, je příliš malé.
Proto bývá zpracování mimo pořadí nejčastěji spojeno se spekulativním vykonáváním. 

% todo komplikace se závislostmi v hlavní paměti
% mělo by to být zde, v konfliktech, nebo v spekulaci?

\subsection{Reorder Buffer}

Pokud jsou instrukce vykonávány mimo pořadí, musí být v~hardwaru udržena informace o~původním pořadí.
Za tímto účelem back-end obsahuje \emph{Reorder Buffer} (ROB).
Jedná se o~cyklický buffer s~typickou kapacitou 100-200 položek \cite{avs}.
Instrukce, jejich výsledky a související příznaky jsou zde uchovávány v~programovém pořadí.

Do fáze commit vstupují instrukce na čele ROB.
Jakmile instrukce opustí ROB, přestává být spekulativní.
Výsledek instrukce je propsán do architekturních registrů a instrukce je považována za potvrzenou.

Zaplněním ROB vzniká strukturní konflikt a předchozí fáze linky se musí pozastavit.

\subsection{Algoritmus Tomasulo}
% dynamic scheduling
% Reservation Stations
% Register Renaming
% Handling Dependencies

Dva nejznámější algoritmy pro dynamické plánování instrukcí jsou \emph{ScoreBoarding} a \emph{Tomasulo}.
ScoreBoarding má velká omezení\footnote{ScoreBoarding je omezen na plánování v~rámci \emph{basic bloku} instrukcí, WAW a WAR konflikty řeší čekáním.}, proto blíže rozvedu pouze algoritmus Tomasulo.

Hlavním hardwarovým prvkem algoritmu je \emph{rezervační stanice} (RS), buffer pro ukládání operandů.
RS může být centrální, nebo individuální pro každý druh instrukcí.
Položka RS má následující pole:
\begin{itemize}
    \item \emph{busy bit}  -- příznak, zda je položka obsazena a validní,
    \item \emph{operace}   -- druh operace (například sčítání),
    \item \emph{operandy}  -- trojice (hodnota, tag, valid),
    \begin{itemize}
        \item \emph{hodnota} -- kopie hodnoty operandu,
        \item \emph{tag}     -- ukazatel na registr operandu,
        \item \emph{valid}   -- příznak, zda je pole hodnota validní,
    \end{itemize}
    \item \emph{destinace} -- ukazatel na registr, do kterého má být výsledek zapsán.
\end{itemize}
Tato struktura řeší konflikty RAW -- instrukce je poslána do funkční jednotky až v~moment, kdy jsou všechny operandy připraveny.

Konflikty WAR a WAW jsou vyřešeny \emph{přejmenováním registrů}.
Podstata těchto falešných konfliktů není datová, jedná se o~\emph{konflikt jmen}.
Výsledek každé instrukce se zapíše do nového, unikátně pojmenovaného registru.
Dekódované instrukce místo původních jmen operandů použijí jejich nejaktuálnější přejmenování.
S~novými jmény registrů v~kódu zůstanou pouze pravé RAW konflikty.

K ilustraci přejmenování poslouží obrázek \ref{fig:renaming}.
Všimněte si, že vstupní registry používají nejaktuálnější přejmenování a výstupní registry vytvoří nové přejmenování.

\begin{figure}[ht]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \begin{lstlisting}
        add     x2, x1, x1 
        sub     x2, x2, x3 
        mul     x4, x5, x2 
        shr     x5, x1, x4 
\end{lstlisting}
         \caption{Původní jména operandů.}
         \label{fig:renaming1}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \begin{lstlisting}
        add     t0, x1, x1 
        sub     t1, t0, x3 
        mul     t2, x5, t1 
        shr     t3, x1, t2 
\end{lstlisting}
         \caption{Jména operandů po přejmenování.}
         \label{fig:renaming2}
     \end{subfigure}
        \caption{Přejmenování registrů.}
        \label{fig:renaming}
\end{figure}

Je nutné v~hardware udržovat informaci o~posledním přejmenování architekturních registrů, a to ze dvou důvodů: (1) přejmenování operandů nových instrukcí a (2) propsání výsledků při propouštění instrukcí.
Implementace přejmenování vyžaduje dva prvky.
Prvním je tabulka RAT (\emph{Register Alias Table}).
RAT implementuje mapování jmen architekturních registrů na jejich nejaktuálnější přejmenování.

Druhým prvkem je úložiště spočtených výsledků.
Zde jsou možné dvě implementace.
Ve variantě přejmenování v~ROB položky ROB obsahují spočtenou hodnotu instrukce.
Výsledek je ve fázi commit propsán do architekturního registru.

Druhou variantou je přejmenování v~RRF (\emph{Rename Register File}).
Zde se výsledky ukládají do velkého pole registrů.
Pole může být spojeno s~polem architekturních registrů, v~takovém případě propsání do architekturního registru proběhne přepsáním ukazatelů do pole.

Komunikace výsledků probíhá přes sdílenou sběrnici.
Funkční jednotky na sběrnici posílají výsledky; pole registrů, ROB a RS naslouchají a aktualizují své hodnoty.

\subsection{Load/Store jednotka}
\label{ooo_ls}
% pouze aspekty pro ooo, ne spekulaci
% https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp15/cse502/slides/11-ooo_mem.pdf

Podpora vykonávání paměťových instrukcí mimo pořadí vyžaduje speciální hardware.
Instrukce load a store musí být udržovány v~programovém pořadí, v~tabulkách Load Buffer a Store Buffer.

Položka v~Load Bufferu obsahuje vypočtenou adresu.
Adresa může být vypočtena mimo pořadí.
Load může načíst z~paměti, pokud jsou všechny adresy předchozích instrukcí store vypočteny a nepřekrývají se s~loadem.
Pokud je nalezen store se stejnou adresou a položka store bufferu obsahuje zapisovanou hodnotu, může proběhnout optimalizace předání hodnoty, čímž se ušetří jedno čtení z~paměti.
% jak se zjišťuje alias u čtení 1B vs 8B?

Instrukce store může být vykonána, pokud je na čele ROB.

\section{Spekulativní zpracování instrukcí}
% reducing pipeline stalls
% maximize the utilization of execution units

% todo RRF, jak do toho zapadá

% může být skalární spekulace? může
Koncept spekulativního vykonávání jsem již zmínil v~sekci \ref{branchpredict} o~předpovědi skoků.
Při spekulativním vykonávání se spekuluje o~řízení programu, datech a paměťových závislostech.
Instrukce, jejíž výsledek byl předpovězen, je zpracována spolu s~ostatními instrukcemi a běžným výpočtem se zkontroluje, zda byla predikce správná. \cite{QuantApproach}

Kontrola probíhá ve fázi potvrzení instrukce.
Touto fází projdou pouze instrukce, které jsou jistě produktem správné předpovědi.
Pokud predikce odpovídá výsledku, je možné pokračovat ve výpočtu.
Pokud predikce selhala, je nutné všechny následující instrukce označit za nesprávné a smazat jejich rozpočítané výsledky.
Smazat výsledky je nutné, protože mohou být produktem jiných nesprávných výsledků.
% todo je nějaký dependency analysis moc drahý?

% todo poznámka o výjimkách
Výjimky se také musí projevit až v~momentě potvrzení instrukce, protože do té doby není jisté, zda se instrukce skutečně má vykonat. 
Aby bylo možné spekulovat, výsledky výpočtu tedy musí být možné \emph{navrátit}.

Hlavním předpokladem spekulativního vykonávání je ten, že předpovědi mají vysokou úspěšnost.
Každá špatná predikce znamená, že se výpočetní výkon vynakládá na výpočet špatných instrukcí, nebo špatných hodnot operandů.

\subsection{Předvídání skoků}

Při spekulaci o~větvení do linky vstupují a jsou zpracovávány instrukce, o~kterých nemusí být jisté, jestli jsou pro výpočet nutné a že zpracovány být mají.

Superskalární procesor načítá více instrukcí v~jednom taktu.
To znamená, že v~jednom taktu může načíst více než jednu skokovou instrukci.
Fetch jednotka musí být schopna buď zastavit načítání před druhou skokovou instrukcí, nebo musí vypočítat více predikcí v~rámci jednoho taktu.

Detailněji bude předvídání skoků rozvedeno v~sekci \ref{branchpredict}.

\subsection{Předvídání čtení z~paměti}
% https://en.wikipedia.org/wiki/Memory_disambiguation
% https://en.wikipedia.org/wiki/Memory_dependence_prediction

Spekulativní provádění paměťových operací sebou nese komplikaci: efekt spekulativního zápisu do paměti (nebo cache) se nesmí projevit, dokud instrukce není potvrzena (z~důvodu špatné predikce, nebo výjimky).
Z~toho důvodu se data zapisují do Store Bufferu a do paměti se zapisují až při potvrzení instrukce.  
% zmíňka o tom, že spekulativní load taky mění stav (cache), viz spectre

Verzi popsanou v~sekci \ref{ooo_ls} lze rozšířit spekulací.
Instrukce load již nemusí čekat na všechny adresy starších instrukcí store, ale mohou spekulovat, že u~žádné z~instrukcí store s~nedopočítanou adresou k~překrytí nedojde.
Nejjednodušší strategií je spekulovat, že k~překrytí nedojde nikdy.
Ta funguje dostatečně dobře, protože pravděpodobnost pravé závislosti je malá.
Složitější prediktory nebývají v~praxi používány. 
\cite{moshovos1998memory}
% https://ftp.cs.wisc.edu/sohi/theses/moshovos.pdf

Tato spekulace je ověřena, když je store propouštěn.
Adresa store je porovnána s~položkami v~Load Bufferu, v~případě shody jde o~špatnou spekulaci a stejně jako u~spekulace se skoky se vypláchne ROB.

% TODO když bude chuť, ale nepoužívá se v simulátoru
% \subsection{Předvídání hodnot}
% https://hal.science/hal-03325303/document

\section{Předvídání skoků}
\label{branchpredict}

Předpověď skoku má dva komponenty: předpověď podmínky skoku a předpověď cílové adresy skoku.
Předpověď podmínky se nevztahuje pouze na podmíněné skokové instrukce.
U~nepodmíněných skoků je sice jisté, že se skok má provést, jednotka fetch ale sama o~sobě nemůže identifikovat instrukci jako nepodmíněný skok -- instrukce je dekódována až ve fázi decode.
Z~tohoto důvodu prediktory pracují s~\emph{adresou instrukce}.

% první encounter
Při prvním zpracování instrukce na nové adrese není známo, zda se jedná o~instrukci skokovou.
Proto je jedinou možností pokračovat ve zpracování sekvence instrukcí.

Při následujících načteních skokových instrukcí již o~nich existuje záznam a je možné skok předpovídat.

% zotavení
Předpověď musí být ověřena porovnáním s~výsledkem klasického výpočtu skoku.
Při případném zjištění nesprávné předpovědi skoku musí být všechny následující rozpočítané instrukce z~linky vypláchnuty.
Po vypláchnutí linky je registr PC opraven na správný cíl skoku a procesor může pokračovat ve výpočtu.
Nesprávně může být předpovězen i cíl skoku.
V~klasické skalární lince jsou instrukce ze špatně předpovězené větve zrušeny dříve, než jsou vykonány.
% taky feedback pro dynamický prediktor
% todo - je zde nějaká pokuta kromě zahození výsledků?

% možná zmínka o vykrytí branch delaye užitečnou prací při překladu - a delayed branch (MIPS)

\subsection{Předpověď podmínky skoku}

V~této sekci budu používat pojmy \emph{pozitivní a negativní predikce} pro označení situace, kdy prediktor vyhodnotí, že je nebo není splněna podmínka dané skokové instrukce.

Strategie pro predikci podmínky skoku se dělí na dvě skupiny -- statické a dynamické.
Jejich rozdíl v~tom, že dynamické strategie k~predikci používají informace o~chování za běhu programu, typicky historií větvení.
\cite{branchStrategies}

\subsubsection{Statické předpovědi}

Nejjednodušší verzí předpovědi podmínky skoku je statická negativní predikce.
V~tomto případě je vždy načtena následující instrukce a není potřeba předpovídat cíl skoku.
Statická pozitivní predikce může mít vyšší úspěšnost.

% static, cold branches
Jiné statické strategie mohou brát ohled na operační kód instrukce.
Prediktor může například instrukce \texttt{beq} předpovídat negativně a instrukce \texttt{blt} předpovídat pozitivně.
Operační kód instrukce může obsahovat příznak, kterým se prediktor může řídit.
Předpověď v~tomto případě učinil překladač, profilovací nástroj, nebo programátor. \cite{branchStrategies}

Další strategie mohou využít směru skoku (skok dopředu nebo dozadu), nebo vzdálenosti skoku.
Směr skoku je zajímavým ukazatelem, protože v~mnoha programech velkou část skoků směrem zpět tvoří smyčky, které typicky provádějí velký počet iterací.
Nevýhodou je, že předpověď cílové adresy a podmínky nemůže být provedena paralelně.

Statické strategie mají příliš malou úspěšnost pro použití v~současných procesorech.

\subsubsection{Dynamické předpovědi}

Dynamická predikce skoků mění verdikt v~průběhu programu.
Stav prediktoru udržuje historií větvení, znalost historie se používá k~predikci větvení.
V~ideálním případě by každá instrukce (adresa) měla vlastní stav prediktoru, z~praktických důvodů se ale tabulka těchto stavů s~názvem Branch History Table (BHT) adresuje částí adresy v~registru PC.
Pokud je tabulka vůči kódu malá, může dojít ke sdílení stavu prediktoru více instrukcemi. \cite{OrganizationAndDesign}
% todo lze taky použít lru, fifo?
% také lze hashovat

Dynamické prediktory se umí naučit různé vzory \cite{avs}.
Nejjednodušší možností dynamické predikce je predikce na základě stavového automatu.
Podle počtu stavů se prediktory označují jako 1 bitový (2 stavy) nebo 2 bitový (4 stavy), oba jsou znázorněny na obrázku \ref{fsmpredictor}.
Stavy zde představují saturační čítač.

Z~aktuálního stavu je potom odvozena předpověď.
Pokud je aktuální stav v~pravé polovině automatu, potom se skočit má, jinak se předpovídá neskočit.
Přechod do nového stavu se uskuteční při zpětné vazbě prediktoru. Přechod označený \uv{1} znamená, že skok se doopravdy uskutečnil, přechod \uv{0} znamená, že ke skoku nemělo dojít.

\begin{figure}[ht]\centering
% digraph finite_state_machine {
% 	fontname="Helvetica,Arial,sans-serif"
% 	node [fontname="Helvetica,Arial,sans-serif"]
% 	edge [fontname="Helvetica,Arial,sans-serif"]
% 	rankdir=LR;
% 	node [shape = circle];
% 	0 -> 0 [label = "0"];
% 	0 -> 1 [label = "1"];
% 	1 -> 0 [label = "0"];
% 	1 -> 1 [label = "1"];
	
% 	00 -> 01 [label = "1"];
% 	01 -> 10 [label = "1"];
% 	10 -> 11 [label = "1"];
	
% 	01 -> 00 [label = "0"];
% 	10 -> 01 [label = "0"];
% 	11 -> 10 [label = "0"];
	
% 	00 -> 00 [label = "0"];
% 	11 -> 11 [label = "1"];
% }
  \includegraphics[width=10cm]{obrazky-figures/fsmpredictors.png}
  \caption{Schéma 1-bitového prediktoru (nahoře) a 2-bitového prediktoru (dole). }
  \label{fsmpredictor}
  % http://magjac.com/graphviz-visual-editor/
\end{figure}

% feedback, learning period
Dynamickým prediktorům je poskytována zpětná vazba v~podobě informace o~úspěšnosti poslední predikce.
V~případě stavového automatu se stav posune po hraně značené \uv{+}, pokud byla predikce ověřena jako správná, nebo \uv{-} v~opačném případě.
Stavy prediktorů jsou inicializovány na určitou počáteční hodnotu.
První predikce mohou mít špatnou úspěšnost.
Tato fáze se nazývá učící období (learning period).
Po naučení vzoru se úspěšnost prediktoru ustálí.
Každý druh prediktoru je schopen naučit se pouze určitou podmnožinu vzorů.

% Adaptivní prediktor
% todo je ta historie globální, nebo pro instrukci?
Další variantou dynamických prediktorů je \emph{adaptivní prediktor}.
K~predikci větvení jsou použity dvě informace: (1) historie posledních $k$ výsledků větvení dané instrukce a (2) záznam o~chování skokové instrukce v~minulých případech, kdy této instrukci předcházela stejná historie skoků.
Implementace spočívá v~$k$ bitovém posuvném registru historie skoků a tabulce Pattern History Table (PHT): $2^k$ prediktorů pro každou instrukci.
Konkrétní prediktor je adresován vektorem historie a adresou instrukce. \cite{adaptiveBranch}

% todo Korelační prediktor
% adaptivní ale s globální historií
Korelační prediktor místo lokální historie používá jedinou, globální historií.

\subsection{Předpověď cílové adresy skoku}

% BTB, BTAC
K~predikci cílové adresy skoků se využívá cache nazývaná Branch Target Buffer (BTB).
Tato tabulka se indexuje adresou skokové instrukce.

% komplikace s call - RSB
Komplikací jsou nepřímé skokové instrukce, neboli instrukce, jejichž cíl skoku není konstantní.
Takové skoky jsou využívány hlavně při návratu z~funkce (\texttt{ret}), nebo při práci s~ukazateli na funkce.
Predikce by byla nepřesná, protože funkce bývá volána z~několika míst.
Úspěšnost lze zlepšit zásobníkem Return Stack Buffer (RSB), na který se při vstupu do funkce adresy ukládají a při opouštění vybírají.

% loop counter?

\chapter{Architektura RISC-V}
\label{riscvchapter}
% todo ABI

RISC-V je otevřená instrukční sada architektury RISC.
Původně byla vyvinuta na UC Berkeley pro výukové účely.
Instrukční sada je navržena pro maximální jednoduchost a rozšiřitelnost, s~cílem mít malé požadavky na hardware implementace.
\cite{riscvspec}

Definuje registry, samotnou instrukční sadu, její kódování a rozšíření, konvenci volání (ABI), výjimky.
Paměťový systém je navržen jako liitle-endian.
Specifikace připouští varianty s~big-endian nebo oba systémy současně.

% general-purpose register computer
% Type Register-register (0, 3) - 0 memory operands, max 3 alu operands (one output)
% register, immediate, displacement addressing

\section{Architektura RISC}
% RISC a CISC

Architektury RISC (\emph{Reduced Instruction Set Computer}) kladou důraz na jednoduchost hardwaru, který instrukční sadu implementuje a na malou spotřebu energie.
Díky důrazu na nízkou cenu, malé ploše čipu a malému příkonu se často objevuje v~malých zařízeních poháněných bateriemi, například v~IoT a mobilních telefonech.

RISC se vyznačuje menším počtem instrukcí.
Typicky se jedná o~minimální množinu instrukcí, ve které je možné popsat výpočty a práci s~hardwarem.
Do instrukční sady se ale dostávají i další instrukce.
Zajímavostí a extrémním případem je instrukce \href{https://developer.arm.com/documentation/dui0801/h/A64-Floating-point-Instructions/FJCVTZS}{FJCVTZS} instrukční sady ARM.
Jde o~instrukci pro specifický převod čísla float64 na celé číslo.
Tento výpočet je možné provést kombinací jiných instrukcí.
Důvodem přidání této složitější instrukce do instrukční sady navzdory filozofii RISC byl výkon v~důležitém případu užití -- tuto konverzi často provádějí interprety JavaScriptu.

% https://stackoverflow.com/questions/50966676/why-do-arm-chips-have-an-instruction-with-javascript-in-the-name-fjcvtzs
% https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/armv8-a-architecture-2016-additions#:~:text=number%20signed%20addition-,Improved%20Javascript%20data%20type%20conversion,-Javascript%20uses%20the

Situace s~menším množstvím instrukcí se dá vylepšit makry v~assembleru, takzvanými \emph{pseudoinstrukcemi}.
Pseudoinstrukce jsou lexikální náhradou za instrukce s~bližším sémantickým významem.
Tabulka \ref{table:pseudoins} uvádí několik příkladů.
Instrukční sadu je možné tímto způsobem virtuálně rozšířit.
V~současném stavu, kdy je naprostá většina strojového kódu generována překladači, ale programátorský komfort není menší instrukční sadou negativně ovlivněn.

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
Pseudoinstrukce    & Ekvivalent z~instrukční sady & Význam                         \\ \hline\hline
mv rd, rs          & addi rd, rs, 0     & Kopírování hodnoty             \\ \hline
neg rd, rs         & sub rd, x0, rs     & Negace celého čísla            \\ \hline
bgt rs, rt, offset & blt rt, rs, offset & Skok, pokud rs\textgreater{}rt \\ \hline
\end{tabular}
\caption{Příklady pseudoinstrukcí a jejich odpovídajících reálných instrukcí.}
\label{table:pseudoins}
\end{table}

Kódování instrukcí je optimalizováno pro jednoduché načítání a dekódování.
Kódování mívá fixní délkou (např. 4\,B), operační kód a operandy jsou zapsány na předvídatelných místech v~kódu.
Jednodušší dekódování znamená, že k~jeho implementaci je zapotřebí méně hardwarových obvodů a čip má menší spotřebu.

Protipólem je architektura CISC (\emph{Complex Instruction Set Computer}), která definuje větší množství instrukcí.
Jedna instrukce může představovat i složitější operace, například aritmetickou operaci a načtení z~paměti. Kódy mají typicky proměnlivou délku kódování.
Častěji používané operace mají kratší kódy, což se může projevit kompaktnější reprezentací programu v~paměti.

Některé implementace CISC v~rámci fáze dekódování převádí instrukce na sekvenci \emph{mikro-instrukcí}, další části linky dále operují s~touto reprezentací.
Mikro-instrukce více připomínají instrukční sadu RISC.
Dekódování je složitější a proto má větší nároky na hardware.

\section{Instrukční sada}

Specifikace definuje základní celočíselnou sadu instrukcí ve dvou šířkách registrů, 32 bitů (\texttt{RV32I}) a 64 bitů (\texttt{RV64I}).
Verze \texttt{RV64I} je analogická s~\texttt{RV32I}, s~tím rozdílem, že registry mají šířku 64 bitů.
Procesor musí implementovat alespoň jednu z~těchto dvou sad a libovolné množství rozšíření.
Dále budu popisovat pouze 32-bitovou variantu.

Z~pohledu programátora je stav procesoru vyjádřen 31 obecnými registry pojmenovanými \texttt{x1}-\texttt{x31} a speciálními registry \texttt{x0} a \texttt{pc}.
Registr \texttt{x0} obsahuje konstantní hodnotu 0, registr \texttt{pc} obsahuje ukazatel na aktuální instrukci.

Základní instrukční sada definuje aritmetické instrukce, řídící instrukce a instrukce pro práci s~pamětí.
Aritmetické instrukce nevyvolávají výjimky a nekontrolují přetečení.
Přetečení je možné zkontrolovat explicitní podmínkou.
Kódování instrukcí dovoluje vyjádřit přímé hodnoty v~rozsahu 12 bitů.
Načtení 32 bitové konstanty je nutné provést kombinací instrukcí \texttt{LUI} a \texttt{ADDI}.

Skokové instrukce umožňují podmíněné a nepodmíněné relativní skoky.
Skok na absolutní adresu je možný kombinací instrukcí \texttt{LUI} a \texttt{JALR}.
Instrukce musí být zarovnané, proto skok na nezarovnanou adresu vyvolá výjimku.
Uložení návratové adresy provádí instrukce \texttt{JAL}.
Instrukce pro podmíněné skoky provádějí komparaci dvou registrů, vykonávají tedy dvě operace -- \emph{compare} a \emph{branch}.
% https://github.com/emb-riscv/specs-markdown/blob/develop/exceptions-and-interrupts.md#exceptions

Reprezentace instrukce v~paměti zabírá 4 bajty, je zarovnaná na 4 bajty a je zakódována v~jednom ze čtyř formátů\footnote{Rozšíření C navíc definuje komprimované 16-bitové instrukce}.
Formáty mají společné pole pro \emph{opcode} a 5-bitové adresy operandů-registrů.
Liší se ve využití zbylého prostoru, který je interpretován buď jako přímá hodnota, nebo další část \emph{opcode}. \cite{riscvspec}

% privileged specs
Specifikace RISC-V je rozdělena na dvě části.
Druhá část definuje privilegovaný režim, který je nutný k~provozu operačního systému.
Architektura poskytuje tři režimy: Machine (M), Supervisor (S) a User (U).

Speciální registry (\emph{control and status registers} -- CSR) slouží ke sběru statistik a ladění.
Jejich čtení a nastavování je umožněno speciálními systémovými instrukcemi.
Jejich zápis je také vyvolán jako vedlejší efekt vykonávání instrukcí.
Instrukce \texttt{ECALL} slouží k~žádosti o~obsloužení jádrem.
Obdobně jako instrukce \texttt{SYSCALL} z~ISA x86, argumenty jsou definovány podle používaného ABI.

\subsection{Rozšíření instrukční sady}
% rozšíření
Důležitou vlastností RISC-V je rozšiřitelnost.
Jednodušší čipy mohou implementovat pouze ta rozšíření, která ke svému účelu nutně potřebují.
Případně mohou jednoduše specifikovat vlastní instrukce relevantní pro svou doménu.

% genreal IMAFD
Rozšíření implementovaná daným zařízením jsou specifikována základní sadou a výčtem rozšíření.
Typickou sadu rozšíření vyjadřuje zkratka \texttt{RV32IMAFD}, také nazývanou \texttt{RV32G}.
Významy těchto rozšíření jsou uvedeny v~tabulce \ref{table:extensions}.

\begin{table}[ht]
\centering
\begin{tabular}{|c|l|}
\hline
Zkratka  & Popis rozšíření             \\ \hline\hline
M          & Celočíselné násobení a dělení     \\ \hline
A~& Atomické instrukce     \\ \hline
F         & podpora čísel \emph{single} podle standardu IEEE 754-2008\footnote{ANSI/IEEE Std 754-2008, IEEE standard for floating-point arithmetic, 2008.}     \\ \hline
D         & podpora čísel \emph{double} podle standardu IEEE 754-2008     \\ \hline
\end{tabular}
\caption{Nejvýznamnější rozšíření instrukční sady RISC-V. Celý výčet je k~dispozici ve specifikaci RISC-V \cite{riscvspec}.}
\label{table:extensions}
\end{table}

% výčet rozšíření

RV32E je varianta základní instrukční sady, která má pouze 16 obecných registrů.
Je určena pro čipy s~velmi malou plochou.

\section{Paměťový model, vlákna}

RISC-V definuje 32-bitový paměťový prostor.
Přístupy do paměti nemusí být zarovnané, ale nezarovnané přístupy nemusí být atomické.

% RISC-V uses a memory model called “RVWMO” (RISC-V Weak Memory Ordering)
RISC-V používá paměťový model \emph{RISC-V Weak Memory Ordering} (RVWMO).
V~tomto modelu může jádro pozorovat paměťové instrukce jiného jádra v~jiném než původním pořadí.
Pro komunikaci vláken prostřednictvím sdílené paměti musí proto být zavedena synchronizace.
Rozšíření A~k~tomuto účelu představuje instrukce pro atomické paměťové operace.
Instrukce \texttt{FENCE} umožňuje realizovat paměťovou bariéru a tím vynutit pořadí paměťových operací.
% FENCE synchronisation, chapter 6 of manual
% todo je toto faktuální?

% todo komunikace s memory mapped i/o

\section{Aplikační binární rozhraní}
% https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-abi.adoc

Aplikační binární rozhraní definuje konvenci volání a specifika RISC-V pro formáty ELF a~DWARF.
Předepisuje také velikosti a zarovnání pro datové typy jazyka C.
\cite{riscvabi}

Konvence volání označuje způsob komunikace vstupů a výstupů mezi procedurami.
Při popisu se používají aliasy pro jména registrů.
Tato jména odrážejí funkci registru v~konvenci volání.
Například registr \texttt{x2} se také nazývá \texttt{sp} (stack pointer), jelikož ukazuje na vrchol zásobníku.
Pro každý registr je specifikováno, zda má volání procedury zachovat jeho hodnotu, nebo je možné ji přepsat.

RISC-V ABI preferuje předávání argumentů registry.
Celočíselné argumenty se předávají registry \texttt{a0}-\texttt{a7}.
Pro čísla s~plovoucí desetinnou čárkou se používají registry \texttt{fa0}-\texttt{fa7}.
Pokud počet registrů nestačí, další argumenty se předávají \emph{zásobníkem}.

%
% Webová rozhraní
%

\chapter{Webová rozhraní}
\label{webchapter}
% Significance of Web Development

Webový prohlížeč a webové technologie se v~posledních letech staly uživateli očekávaným standardem pro interakci s~počítačem.
Pokud aplikace dokáže splnit své požadavky v~prostředí prohlížeče, potom je pro vývojáře výchozí volbou.
Hlavním důvodem popularity je distribuce -- uživatelé mohou aplikaci najít a začít okamžitě používat.
Vývoj webové aplikace je také rychlejší a levnější než vývoj na alternativních platformách.
% TODO nemuzu najit source

% v posledních letech se hranice začínají ztrácet. Mnoho desktopových aplikací je implementováno za pomoci webových technologií.

S~rostoucí popularitou, implementací nových standardů a vývojem rámcových řešení podíl webových aplikací stále roste.
Mnohé desktopové programy a mobilní aplikace jsou také implementovány webovými technologiemi.
% https://survey.stackoverflow.co/2023/#technology  ??

\section{Základní koncepty a technologie}
% browser, HTTP, HTML, CSS, JS, React
% Frontend vs Backend
% frameworky, bundling, polyfills

Základem obsahu na World Wide Web jsou \emph{hypermédia}.
Hypermediální dokumenty jsou spojeny navigovatelnými referencemi, takzvanými \emph{hyperlinky}.
Společně tvoří síť propojených informací, kde uživatelé mohou pohodlně přecházet mezi jednotlivými stránkami a získávat různorodý obsah, například ve formě textu nebo videa.
Dokumenty mohou být interaktivní -- tímto způsobem jsou implementovány složitější webové aplikace.

Dokumenty, jejich reprezentace a způsob jejich renderování jsou definovány kolekcí standardů vyvinutých WHATWG. Hlavním standardem je HTML Standard, který definuje jazyk HTML a některá API jako například \texttt{localStorage}.
Standard se dále odkazuje na velké množství dalších standardů, např. HTTP, CSS, Unicode, XML a standardy obrazových formátů. \cite{htmlStandard}
% Cascading Style Sheets Level 2 Revision 2, B. Bos, T. Çelik, I. Hickson, H. Lie. W3C.
% Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing, R. Fielding, J. Reschke. IETF.

Tyto standardy jsou implementovány webovými prohlížeči.
Prohlížeč má roli hypermediálního klienta.
Jeho prvním úkolem je komunikovat se servery v~síťové architektuře \emph{klient-server}, ve které klienti poptávají zdroje od speciálních účastníků sítě -- serverů.
Zdroji jsou v~případě webu myšleny hypertextové dokumenty, multimédia a další soubory.
Komunikace mezi uzly je rozvedena v~následující sekci.

Druhým úkolem prohlížeče je tyto dokumenty zobrazovat uživateli.
Uživatelská rozhraní blíže rozvedu v~sekci \ref{ui_scripting}.

\subsection{Přenosové protokoly}
% main concepts of HTTP

Výměna dokumentů mezi serverem a klientem probíhá bezstavovým textovým protokolem \emph{HTTP}.
Jedná se o~protokol typu request/response aplikační vrstvy.
Využívá transportní protokol TCP, poskytuje tedy spolehlivý přenos.

Zdroje jsou na webu identifikované pomocí \emph{Uniform Resource Identifier} (URI).
V~hlavičce zprávy typu request se přenáší verze protokolu, metoda, URI požadovaného zdroje, hlavičky s~informacemi o~klientovi a požadovaném zdroji a v~některých případech i tělo zprávy s~libovolnou sekvencí bajtů.
Server odpovídá zprávou response, která obsahuje statusový kód, hlavičky a data určitého typu.
\cite{http-rfc}

HTTP poskytuje několik sémantických metod.
Metody \texttt{GET} a \texttt{HEAD} slouží k~získání dokumentů.
Metodami \texttt{DELETE}, \texttt{POST} a \texttt{PUT} klient žádá server o~provedení nějakého \emph{vedlejšího efektu}, například přidání nového příspěvku na sociální síť.

Trojciferný statusový kód odpovědi indikuje, zda byl příspěvek zpracován.
Konkrétní kódy mají specifické významy, dělí se do pěti skupin: informační, úspěchové, přesměrovací, chybové na straně klienta a chybové na straně serveru.

% QUIC
Požadavky na web se neustále vyvíjí a existuje poptávka po alternativních protokolech.
Protokol HTTP se vyvíjel do verze 2 a 3.
Firma Google představila vlastní protokol QUIC, který především snižuje marži šifrované komunikace a umožňuje použít jedno spojení k~přenosu několika streamů (multiplexing).
Vyšší efektivita přenosu se pozitivně projevuje především při používání na pomalejších mobilních sítích.

\subsubsection{Sezení}

HTTP je bezstavovým protokolem, aplikace ale pro své cíle může vyžadovat použití kontextu.
Příkladem kontextu může být identita uživatele pro autorizaci požadavku nebo personalizaci.
Sezení (sekvence dotazů sdílející kontext) je často implementováno pomocí \emph{cookies}.
Cookie je textový token vytvořený serverem, přenášený v~hlavičce každého dotazu.
Konkrétní způsob jejich využití závisí na serveru.
\cite{cookies}

Jedním ze schémat k~ustanovení spojení je identifikátor sezení (\emph{session ID}).
Na straně serveru je tento identifikátor z~hlavičky přečten a spojen s~konkrétními daty v~databázi sezení.

Druhým častým způsobem navázání sezení je technologie JSON Web Token (JWT).
Tento token obsahuje libovolná textová data a datum expirace.
Token je kryptograficky podepsán, aby byla zaručena integrita dat.

\subsubsection{Zabezpečení}

% TLS
Protokol HTTP neposkytuje důvěrnost ani integritu.
Pokud je aplikace vyžaduje, je potřeba navázat spojení přes protokol HTTPS.
HTTPS je protokol HTTP přenášený pomocí kryptografického protokolu \emph{Transport Layer Security} (TLS).

Protokol spočívá v~ustanovení symetrického klíče sezení.
Identita serveru je také ověřena u~důvěřované \emph{certifikační autority}.

Ustanovení TLS (verze 1.2) spojení přidává latenci 2 RTT (Round Trip Time).
S~navázáním TCP spojení a samotným HTTP dotazem se vytvoření nového spojení dostává na minimální zpoždění 4 RTT (není započítáno vyhledání v~DNS).
Takové zpoždění se může významně negativně projevit dlouhou čekací dobou na načtení stránky, obzvlášť na mobilních sítích.
TLS verze 1.3 přináší schopnost obnovit spojení na dříve navštívenou stránku za 2 RTT díky funkcionalitě 0-RTT. \cite{tls}
% https://blog.cloudflare.com/introducing-0-rtt

% mitm

% session stealing
Hodnoty cookies jsou přenášeny v~hlavičkách HTTP, nešifrovaně.
RFC 6265 \cite{cookies} doporučuje, aby byly citlivé hodnoty šifrovány a podepsány, a to i v~případě, že je hlavička přenášena přes HTTPS.

\section{Skriptování}
\label{ui_scripting}

Interaktivitu uživatelských rozhraní pohání skriptovací jazyk JavaScript.
Skriptům jsou přístupná API pro manipulaci DOM (Document Object Model), což je stromová reprezentace aktuálního dokumentu.
Skriptování se používá k~vytváření dynamických a interaktivních webových rozhraní, validaci formulářů a práci s~různými API.
Webová API například umožňují skriptům pracovat se souborovým systémem, nebo komunikovat pomocí HTTP.

Příklady použití rozhraní pro manipulaci stránky jsou volání jako \texttt{element.\-append\-Child}, nebo \texttt{query\-Selector}.
Při vývoji složitých aplikací se ale typicky tato volání používají pouze nepřímo prostřednictvím \emph{knihoven}.
Mezi nejznámější zástupce patří React, Angular, a Vue.js.

% TODO https://2022.stateofjs.com/en-US
K~vývoji webových aplikací se velmi často používá jazyk TypeScript.
TypeScript rozšiřuje syntax JavaScriptu o~typové informace, což umožňuje lepší nápovědy a kontroly ve vývojovém prostředí.
Zdrojový kód je nutné před vykonáním transpilovat do JavaScriptu.

V~současné době je rozvíjena technologie WASM, což je virtuální stroj založený na bajtkódu.
Tato technologie umožňuje psát programy pro web v~libovolném kompilovaném programovacím jazyce a slibuje vyšší výkon.
Technologie je však stále v~zárodku, proto ji v~této práci podrobněji nepopíšu. 

\subsection{React}

React je open-source\footnote{\href{https://github.com/facebook/react}{https://github.com/facebook/react}} knihovna vyvinutá firmou Meta pro vytváření uživatelských rozhraní.
Základním stavebním blokem UI je \emph{komponent}.
Každá jednotlivá stránka se skládá ze stromové hierarchie komponentů.

Komponent je uzavřený celek s~definovaným rozhraním, který implementuje jeden prvek uživatelského rozhraní včetně jeho chování a vzhledu.
Vývoj aplikace orientovaný na komponenty podporuje znovupoužitelnost, modularitu a testovatelnost.
Komponenty mohou mít vlastní vnitřní stav a vykonávat kód v~různých stádiích životního cyklu (při změně parametrů, zániku instance komponentu apod.).

React k~definici komponentů používá rozšíření syntaxe JavaScriptu nazývané JSX.
Díky JSX je možné vkládat fragmenty HTML přímo do skriptů.
Příklad jednoduchého komponentu je uveden v~příkladu \ref{jsx}.
Soubory \texttt{.jsx} je nutné zkompilovat do standardního JavaScriptu. 

\begin{lstlisting}[caption={Příklad komponentu definovaného v~\texttt{.jsx} souboru. Komponent renderuje array předanou v~parametrech jako list v~HTML. Komponent definuje jak logiku, tak i vzhled. S~fragmenty HTML je možné pracovat jako s~hodnotami.},captionpos=b,label=jsx]
export default function List({items}) {
    const listItems = items.map(item =>
        <li key={item.id}>
            <b>{item.text}</b>
        </li>
    );
    return <ul className="large-font">{listItems}</ul>;
}
\end{lstlisting}

Knihovna je velmi populární, díky tomu lze v~projektech využít velkého množství dalších knihoven (například pro práci s~globálním stavem), nebo využít celé předpřipravené komponenty.
Nevýhodou je nižší výkon aplikací oproti řešení v~čistém JavaScriptu a velikost knihovny, kterou je nutné stáhnout při návštěvě stránky (~130\,kB kódu).
% todo cite?

V~současné době je doporučováno React používat prostřednictvím jiného rámcového řešení, jakým je například \emph{Next.js}.

\subsection{Next.js}

Next.js\footnote{\url{https://nextjs.org/}} je \emph{fullstackovým frameworkem}.
Znamená to, že výsledná aplikace zastává funkci serveru i klienta.
Tento framework doplňuje React do uceleného řešení pro webové aplikace.

Strom stránek je definovaný strukturou souborů a složek (file-system based router).
Jedná se o častý způsob definice struktury webové aplikace.
Každá stránka je definovaná kořenovým komponentem.

Stránky jsou alespoň částečně staticky renderované na serveru.
Pokud stránka obsahuje dynamický obsah, je dodatečně renderovaný na straně klienta.
Tato kombinace renderování na stranách serveru i klienta se nazývá hybridní přístup k~renderování.
Pouze první stránka je stažena ze serveru -- následující navigace mezi stránkami jsou vykonány JavaScriptem.

Framework se také stará o~cachování, přednačítání zdrojů a další optimalizace s~cílem zvýšit výkon aplikací.
Významně také zjednodušuje nasazení aplikace do provozu prostřednictvím serverů firmy Vercel, autora frameworku. \cite{nextjsDocs}

\section{Uživatelská rozhraní}

% User Experience of Web Browsing - The Relationship of Usability and Quality of Experience
% citace se mi moc nehodí

% IS0 DIS 9241-11 -- usability definition
\emph{Uživatelská rozhraní} (User Interface -- UI) se převážně zaměřují na aspekt \emph{použitelnosti} -- efektivitu a spokojenost, s~jakou je uživatel schopen dosáhnout svých cílů.
Celková příjemnost produktu ale může záviset na více faktorech, než pouze použitelnost.
Pokud se návrh aplikace zaměří pouze na použitelnost, celkový dojem z~aplikace nemusí být optimální. 
\cite{pleasureInProduct}

Použitelnost je ovlivněna mnoha faktory, například intuitivností, spolehlivostí, nebo úsilím nutným k~používání aplikace.
Estetická příjemnost, uspořádanost a čitelnost rozhraní jsou také důležitými faktory pro její pozitivní vnímání. \cite{webAesthetics}

\subsection{Použitelnost}

Použitelnost je vlastnost systému vyjadřující jeho jednoduchost pro používání i naučení.

% https://www.nngroup.com/articles/cognitive-walkthroughs
% todo překlad Cognitive walkthrough ??
Jedním ze způsobů evaluace použitelnosti je kognitivní analýza (\emph{Cognitive walkthrough}).
Tato metoda se zaměřuje na nejdůležitější úkoly v~aplikaci a jednotlivé kroky, ze kterých se úkol skládá.
Analýzu provádí vývojář z~perspektivy nového uživatele a posuzuje jeho schopnost dosáhnout svých cílů při použití aplikace.
Metodu je možné začít využívat již v~raných fázích vývoje, jakmile je k~dispozici prototyp.
Výstupem analýzy je seznam prvků rozhraní, které mohou být pro nové uživatele představovat překážky.
\cite{cognitiveWalkthrough}

% Postup
Postup kognitivní analýzy je jednoduchý.
Postupně jsou analyzovány jednotlivé úkoly z~předem definovaného seznamu.
Jeden z~účastníků provádí vybraný úkol a zastavuje se při každém kroku.
Ostatní účastníci debatují o~potenciálu uživatele úspěšně krok provést.
K~hodnocení jim pomáhají předem připravené otázky.

\subsection{Dostupnost}
% accesibility
% screen readers
% https://en.wikipedia.org/wiki/Web_Content_Accessibility_Guidelines

Dostupnost se v~kontextu webu zaměřuje na podporu široké škály možností interakce s~aplikacemi.
Důležitou skupinou jsou zde invalidní uživatelé a uživatelé mobilních zařízení.
Standardizační organizace World Wide Web Consortium (W3C) vydává směrnice \emph{Web Content Accessibility Guidelines}\footnote{\href{https://www.w3.org/WAI/standards-guidelines/wcag/}{https://www.w3.org/WAI/standards-guidelines/wcag/}} určené pro vývoj dostupných aplikací.

Velká část podpory dostupnosti spočívá v~anotaci obsahu tak, aby byl lépe strojově zpracovatelný.
Příkladem může být význam vstupních polí, správné použití sémantických HTML značek, nebo textové alternativy k~obrazovým datům.
Prezentace by se měla adaptovat na různá rozlišení a orientaci obrazovky.
Měla by mít dostatečný kontrast textu a pozadí.
Důležitá je také možnost ovládat celou aplikaci pomocí klávesnice.

Accessible Rich Internet Applications (ARIA) je skupina atributů, kterými lze sémanticky anotovat HTML značky.
Například atribut \texttt{role} u~značky vyjadřuje jeho roli v~rozhraní a používá se v~situacích, ve kterých nelze použít vhodnou sémantickou značku.
Role elementu může být strukturní (\texttt{tooltip}, \texttt{note}), widget (\texttt{searchbox}, \texttt{slider}) a další.

Kvalitní knihovny s~prvky uživatelského rozhraní jsou navrženy v~souladu se standardy a mohou zajistit lepší dostupnost bez nutnosti investovat značné množství zdrojů do vyvinutí vlastního řešení.
% Jak se accessibility vyvíjí: https://webaim.org/projects/million/#aria

\subsection{Měření uživatelského zážitku}
%  "uživatelský zážitek" nebo "uživatelský komfort"

Měření uživatelského zážitku ve webových aplikacích je klíčovým prvkem moderního návrhu a vývoje aplikací.
Pro vytvoření dobrého rozhraní je nezbytné porozumět tomu, jak uživatelé vnímají a využívají webové aplikace.
Uživatelský zážitek (UX -- \emph{User Experience}) zahrnuje vizuální dojem, snadnost navigace, efektivitu úkonů a celkovou přívětivost rozhraní.
Měření těchto aspektů, ať už manuální, nebo automatické, pomáhá vývojářům identifikovat problémy a zlepšovat užitečnost aplikace.

Kromě designu je důležitý i výkon aplikace, který se projevuje délkou čekání.
Uživatelé vnímají vizuální odezvu jako okamžitou, pokud se odehraje do 30\,ms.
Vnímaná kvalita významně klesá, pokud je odezva pomalejší než 100\,ms. \cite{interactivityDelay}

% flow, immersion

\subsubsection{Kvalitativní metody}
% interviews
% User Testing, Session Analysis, A/B

Vnímání produktu jeho uživatelem je velmi subjektivní.
Pokud chceme získat povědomí, je nutné provést průzkum.

Poskytnutí formuláře nebo dotazníku pro zpětnou vazbu je nejjednodušším způsobem sběru dat od uživatelů.
Má ale zásadní nevýhodu -- uživatel musí věnovat vlastní čas a úsilí k~poskytnutí zpětné vazby.
Důsledkem je, že jsou hlášeny pouze problémy, které si uživatel uvědomuje, dokáže popsat a jsou pro něj dostatečně důležité.
Navíc uživateli musí záležet na tom, aby byl nedostatek opraven.

Uživatelská přívětivost je také měřitelná analýzou sezení.
Metoda \emph{Real User Monitoring} (RUM) instrumentuje aplikaci a tvoří záznam akcí v~čase.
Poznatky o~nedostatcích lze získat porovnáním akcí úspěšných a neúspěšných uživatelů.
% https://en.wikipedia.org/wiki/Real_user_monitoring

% focus groups, interviews

\subsubsection{Kvantitativní metody}
\label{kvantMethods}
% Cumulative Layout Shift (CLS)
% Time to Interactive (TTI)
% Largest Contentful Paint (LCP)
% Page Load Time (PLT) or Speed Index (SI)
% Interaction to Next Paint (INP)

% https://support.google.com/webmasters/answer/9205520?hl=en

Stav aplikace z~pohledu výkonu lze měřit značně jednodušeji.
\emph{Web Vitals} je soubor metrik vyjadřujících kvalitu uživatelského zážitku převážně týkajících se rychlosti načítání aplikace a odezvě po interakci.
Metriky odrážejí architekturu aplikace i infrastrukturu, na které je aplikace nasazena.
Následuje popis několika metrik.

\emph{Largest Contentful Paint} (LCP) měří dobu od navigace na stránku do zobrazení největšího prvku UI.
Tento čas zahrnuje dobu sestavení spojení se serverem.
Za dobrý výsledek se považuje hodnota menší než 2,5\,s.

\emph{Cumulative Layout Shift} (CLS) měří míru neočekávaných posunů prvků rozhraní.
Tyto posuny jsou způsobeny postupným načítáním obsahu, typicky obrázků, reklam a jiného dynamického obsahu.
Velká nestabilita rozvržení stránky způsobuje frustraci uživatele a stává se, že vyvolá nechtěnou akci.

\emph{Interaction to Next Paint} (INP) měří responzivitu aplikace jako prodlevu mezi interakcí a prezentací další vyrenderované obrazovky.
Za přijatelné zpoždění se považuje 200\,ms.
Některé akce přirozeně trvají delší dobu, v~takovém případě je dobré dát vizuální zpětnou vazbu, aby uživatel nenabyl dojmu, že aplikace přestala odpovídat. 

Další měřené metriky zahrnují \emph{Time to First Byte} (TTFB), nebo \emph{First Contentful Paint} (FCP).

Vyhledávače tyto metriky využívají k~odhadu kvality webové stránky a její upřednostnění ve výsledcích, což může být důležité pro dosažení cílů organizace.
Výsledky měření mají určitou distribuci hodnot podle výkonu zařízení a kvality internetového spojení se serverem.
Je doporučeno pracovat se 75. percentilem hodnot metrik.
Nekvalitní připojení i slabější hardware je možné v~prohlížeči emulovat. 
\cite{coreWebVitals}

% number of clicks to finish a task
% load times

\section{Architektura systému}
% Aplikační rozhraní
% https://htmx.org/essays/hypermedia-apis-vs-data-apis/

V~architektuře webových aplikací se klíčově uplatňuje model klient-server, v~rámci kterého klient (webový prohlížeč) a server komunikují přes standardizované protokoly.
Dva základní přístupy ke komunikaci jsou hypermediální API a datová API.

Hypermediální API je rozhraní, které poskytuje hypermédia.
Typicky se jedná o~dokumenty nebo části dokumentu v~jazyce HTML, obrázky a videa ve formátech přímo podporovaných prohlížeči.
Tyto odpovědi jsou přímo zobrazovány klientem.
Jedná se o~původní přístup poskytování dat v~kontextu webových aplikací.
Příkladem jsou statické HTTP servery, nebo servery renderující HTML při dotazu (\emph{Server-Side Rendering}).

Oproti tomu datové API poskytuje strukturovaná data, která nejsou určena k~přímému zobrazení.
Prvotní stažení stránky stále proběhne v~podobě HTML, součástí stránky je ale JavaScriptový kód, který dál pracuje s~datovým API.
Příchozí data jsou zpracovávána do nového stavu DOM, který prohlížeč prezentuje uživateli.

Populárními zástupci knihovnen, kterými lze implementovat jak hypermediální, tak datová API jsou například Django, Express, nebo Ruby on Rails.

% SPA/MPA

% globální stav 
% mvc? :(

\subsection{Globální stav aplikace}

Často řešeným problémem aplikací je komunikace mezi moduly.
V~JavaScriptových aplikacích se tento problém často řeší globálním stavem.
Globální stav je množina dat \emph{dostupná ze všech částí aplikace}.
Typicky jsou sdílena data o~sezení, konfigurace aplikace a uživatelská data. 

Dříve zmíněná knihovna React podporuje práci s~globálním stavem ve formě \texttt{Context API}.
\emph{Kontext} vytvořený v~určitém komponentu je zpřístupněn všem jeho potomkům ve stromu.
Knihovna \emph{Redux} je dalším způsobem jak v~Reactové aplikaci implementovat správu globálního stavu. 
Stav je zde reprezentován jediným objektem, který je možné libovolně číst.
Změny globálního stavu jsou možné výhradně skrze \emph{akce} -- čisté funkce transformující daný stav do nového stavu.
Redux vybízí k~centralizaci logiky aplikace v~definici stavu a jeho akcích.
Nabízí také další zajímavé funkce jako perzistenci stavu napříč sezeními, nebo ladící rozšíření do prohlížeče s~možností přehrání změn stavu.
% https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/

\section{Vývojové praktiky}
% git, CI, deployment, packages
% git-flow?

Při vývoji webových aplikací je výhodné používat moderní vývojové praktiky, které zajišťují efektivní správu kódu, plynulý vývoj, komunikaci a nasazení aplikace do provozu.
Cílem je co největší část repetitivní práce \emph{automatizovat}.

\emph{Continuous Integration} (CI) je koncept automatizace akcí jako například sestavení projektu, testování a nasazení.
Automatizace především snižuje pravděpodobnost lidské chyby při nasazení.
Součástí procesu je generování hlášení o~výsledcích akcí.
CI je úzce spjatý se \emph{systémem správy verzí}.

\emph{Git}\footnote{\url{https://git-scm.com/}}, nejpopulárnější systém pro správu verzí kódu, hraje klíčovou roli v~dokumentování a uchování historie změn v~kódu.
Hlavním konceptem gitu je \emph{commit}, záznam o~stavu kódu.
Každý commit je uzlem v~grafu, kde hrany vyjadřují následnost commitů.
Události v~repozitáři mohou být spouštěčem pro automatizované testování a nasazení. \cite{Dhakad2023AdoptingCI}

% Packages
Současným trendem je široce využívat knihoven ke~zrychlení a usnadnění vývoje.
S~tím napomáhá manažer balíčků, který poskytuje jednoduchou správu závislostí projektu.
Populární knihovny zároveň bývají robustní, dobře navržené a mají otevřené zdrojové kódy (open source).

\subsection{Nasazení}

Proces nasazování do provozu představuje důležitý okamžik v~životním cyklu webové aplikace.
Automatizované postupy umožňují rychlé a konzistentní nasazení nových verzí na produkční nebo předprodukční server.
To nejen minimalizuje riziko lidských chyb, ale také šetří manuální úkony.

% Virtualizace
Častým problémem při nasazování aplikace na server bývají její požadavky na prostředí -- verze operačního systému, nainstalované programy, proměnné prostředí a další.
Systém \emph{Docker}\footnote{\url{https://www.docker.com/}} tento problém řeší tak, že celé prostředí popíše předpisem pro jeho vytvoření. \cite{Dhakad2023AdoptingCI}
Při spuštění \emph{kontejneru} virtualizační vrstvou se tento předpis vykoná v~izolovaném prostředí.
Výsledkem je předvídatelné nasazení převážně abstrahované od konkrétního systému.
Změna serveru na kterém aplikace běží nepředstavuje žádné nebo pouze minimální změny v~kódu a konfiguraci. 
% no musí být stejná architektura procesoru v určitých případech?

\subsection{Testování}

Robustní testovací řešení významně usnadňuje vývoj nových funkcí aplikace, stejně jako změny v~existující funkcionalitě.

Existují různé druhy testování softwaru.
Každé se zaměřuje na určitou vrstvu softwarového produktu:
\begin{itemize}
    \item Testování na úrovni softwarových modulů (Unit Testing),
    \item Testování interakce modulů (Integration Testing),
    \item Holistické testování (End-to-end testing).
\end{itemize}

Testování by mělo být automatizované.
Ponechání procházejících testů v~projektu zabraňuje regresím.
Nevhodný návrh testů může mít za důsledek jejich přílišnou závislost na vnitřní implementaci.
Při změnách v~implementaci takové testy vyžadují častou opravu, což ztěžuje údržbu.

Webové rozhraní lze testovat mnoha způsoby a má svá specifika.
Testy mohou ověřovat, zda se na stránce vyskytuje daný text a provést gramatickou kontrolu.
Testy pro dostupnost mohou kontrolovat kontrast textu a anotaci HTML značek.
Můžeme aplikovat kvantitativní metody (sekce \ref{kvantMethods}) a sbírat metriky od skutečných uživatelů.

Testování funkcí webových uživatelských rozhraní je často prováděno manuálně.
Rozhraní bývají složitá a jejich automatizace je velmi pracná na implementaci a údržbu. 
GUI by mělo být testováno ve více prohlížečích.

