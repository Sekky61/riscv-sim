#!/bin/bash
# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([base-path],[],[Path prefix of the app],[""])
# ARG_OPTIONAL_SINGLE([internal-api],[],[Internal API prefix],[simserver:8000])
# ARG_OPTIONAL_SINGLE([external-api],[],[External API prefix],[/api/sim])
# ARG_OPTIONAL_SINGLE([http-port],[],[HTTP port],[3120])
# ARG_OPTIONAL_SINGLE([https-port],[],[HTTPS port],[3121])
# ARG_OPTIONAL_SINGLE([ssl-conf],[],[Path to SSL configuration],[])
# ARG_OPTIONAL_SINGLE([certs-path],[],[Path to SSL certificates],[])
# ARG_OPTIONAL_SINGLE([build-strategy],[],[Build strategy (pull/build)],[build])
# ARG_OPTIONAL_SINGLE([compose-command],[],[Docker compose command (docker compose/docker-compose)],[docker compose])
# ARG_POSITIONAL_SINGLE([command],[Command to execute (up/down/status/logs)],[])
# ARG_HELP([Management script for RISC-V Simulator Docker environment])
# ARG_VERSION([echo $0 v0.1])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='hv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_base_path=""
_arg_internal_api="simserver:8000"
_arg_external_api="/api/sim"
_arg_http_port="3120"
_arg_https_port="3121"
_arg_ssl_conf=
_arg_certs_path=
_arg_build_strategy="build"
_arg_compose_command="docker compose"


print_help()
{
	printf '%s\n' "Management script for RISC-V Simulator Docker environment"
	printf 'Usage: %s [--base-path <arg>] [--internal-api <arg>] [--external-api <arg>] [--http-port <arg>] [--https-port <arg>] [--ssl-conf <arg>] [--certs-path <arg>] [--build-strategy <arg>] [--compose-command <arg>] [-h|--help] [-v|--version] <command>\n' "$0"
	printf '\t%s\n' "<command>: Command to execute (up/down/status/logs)"
	printf '\t%s\n' "--base-path: Path prefix of the app (default: '""')"
	printf '\t%s\n' "--internal-api: Internal API prefix (default: 'simserver:8000')"
	printf '\t%s\n' "--external-api: External API prefix (default: '/api/sim')"
	printf '\t%s\n' "--http-port: HTTP port (default: '3120')"
	printf '\t%s\n' "--https-port: HTTPS port (default: '3121')"
	printf '\t%s\n' "--ssl-conf: Path to SSL configuration (no default)"
	printf '\t%s\n' "--certs-path: Path to SSL certificates (no default)"
	printf '\t%s\n' "--build-strategy: Build strategy (pull/build) (default: 'build')"
	printf '\t%s\n' "--compose-command: Docker compose command (docker compose/docker-compose) (default: 'docker compose')"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--base-path)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_base_path="$2"
				shift
				;;
			--base-path=*)
				_arg_base_path="${_key##--base-path=}"
				;;
			--internal-api)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_internal_api="$2"
				shift
				;;
			--internal-api=*)
				_arg_internal_api="${_key##--internal-api=}"
				;;
			--external-api)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_external_api="$2"
				shift
				;;
			--external-api=*)
				_arg_external_api="${_key##--external-api=}"
				;;
			--http-port)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_http_port="$2"
				shift
				;;
			--http-port=*)
				_arg_http_port="${_key##--http-port=}"
				;;
			--https-port)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_https_port="$2"
				shift
				;;
			--https-port=*)
				_arg_https_port="${_key##--https-port=}"
				;;
			--ssl-conf)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ssl_conf="$2"
				shift
				;;
			--ssl-conf=*)
				_arg_ssl_conf="${_key##--ssl-conf=}"
				;;
			--certs-path)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_certs_path="$2"
				shift
				;;
			--certs-path=*)
				_arg_certs_path="${_key##--certs-path=}"
				;;
			--build-strategy)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_build_strategy="$2"
				shift
				;;
			--build-strategy=*)
				_arg_build_strategy="${_key##--build-strategy=}"
				;;
			--compose-command)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_compose_command="$2"
				shift
				;;
			--compose-command=*)
				_arg_compose_command="${_key##--compose-command=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 v0.1
				exit 0
				;;
			-v*)
				echo $0 v0.1
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'command'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_command "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# To compile it, run
# argbash argbash_template.m4 -o manage-riscvsim.sh


# Print error message
error() {
    echo -e "Error: $1" >&2
    exit 1
}

# Print success message
success() {
    echo -e "$1"
}

# Print warning message
warning() {
    echo -e "Warning: $1"
}

# Validate ports
validate_port() {
    if ! [[ $1 =~ ^[0-9]+$ ]] || [ $1 -lt 1 ] || [ $1 -gt 65535 ]; then
        error "Invalid port number: $1"
    fi
}

# Validate build strategy
validate_build_strategy() {
    if [[ "$1" != "pull" && "$1" != "build" ]]; then
        error "Build strategy must be either 'pull' or 'build'"
    fi
}

# Validate docker compose command
validate_docker_compose() {
    if [[ "$1" != "docker compose" && "$1" != "docker-compose" ]]; then
        error "Docker compose command must be either 'docker compose' or 'docker-compose'"
    fi
}

# Check if required files exist
check_requirements() {
    if [ ! -f "docker-compose.yml" ]; then
        error "docker-compose.yml not found in current directory"
    fi

    if [ "$_arg_command" = "up" ]; then
        if [ ! -f "$_arg_ssl_conf" ]; then
            warning "SSL configuration file not found at $_arg_ssl_conf"
        fi
        if [ ! -d "$_arg_certs_path" ]; then
            warning "Certificates directory not found at $_arg_certs_path"
        fi
    fi
}

# Export environment variables for docker-compose
export_variables() {
    export BASE_PATH="$_arg_base_path"
    export INTERNAL_SIM_API_PREFIX="$_arg_internal_api"
    export EXTERNAL_SIM_API_PREFIX="$_arg_external_api"
    export HTTP_PORT="$_arg_http_port"
    export HTTPS_PORT="$_arg_https_port"
    export SSL_CONF_PATH="$_arg_ssl_conf"
    export CERTS_PATH="$_arg_certs_path"
}

# Execute docker-compose commands
execute_command() {
    compose=$_arg_compose_command
    case $_arg_command in
        up)
            if [ "$_arg_build_strategy" = "build" ]; then
                success "Building and starting services..."
                $compose up --build -d
            else
                success "Pulling images and starting services..."
                $compose pull
                $compose up -d
            fi
            ;;
        down)
            success "Stopping services..."
            $compose down
            ;;
        status)
            success "Checking service status..."
            $compose ps
            ;;
        logs)
            success "Showing logs..."
            $command logs --tail=100 -f
            ;;
        *)
            error "Invalid command: $_arg_command. Must be one of: up, down, status, logs"
            ;;
    esac
}

# Main script execution
main() {
    validate_port "$_arg_http_port"
    validate_port "$_arg_https_port"
    validate_build_strategy "$_arg_build_strategy"
    validate_docker_compose "$_arg_compose_command"
    check_requirements
    export_variables
    execute_command
}

main

# ] <-- needed because of Argbash
